/*
 * generated by text 2.12.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import restInPeace.APIRest
import restInPeace.CommandRest
import restInPeace.Method
import restInPeace.Parameter
import java.util.HashSet
import org.eclipse.emf.common.util.EList
import java.util.List
import java.util.regex.Matcher
import java.util.ArrayList
import java.util.regex.Pattern
import restInPeace.Response

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PythonGenerator extends AbstractGenerator {

	override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext ctx){
		
		fsa.generateFile(res.URI.trimFileExtension.appendFileExtension("py").lastSegment,
		res.allContents.filter(APIRest).toIterable.head.compile.toString)
		
	}
	
	def dispatch compile(APIRest api) '''
	# -*- coding: utf-8 -*-
	
	from flask import Flask, request
	from flask_negotiate import consumes, produces
	
	app = Flask(__name__)
	
	«FOR command : api.commands»
		«command.compile»
	«ENDFOR»
	
	if __name__ == '__main__':
	    app.run()'''
	
	def dispatch compile(CommandRest cmd) '''	
	@app.route('«cmd.toFlaskPath()»', methods=['«cmd.method»'])
	«cmd.entryFormats.toConsumes()»
	«cmd.outputFormats.toProduces()»
	def «cmd.name»(«cmd.toMethodParameters()»)
		«"'''"»
		«cmd.description» 
		
		«FOR i : cmd.entryFormats»
		:consumes «i»
		«ENDFOR»
		«FOR o : cmd.outputFormats»
		:produces «o»
		«ENDFOR»
			
		«FOR param : cmd.parameters»
			«param.compile»
		«ENDFOR»
		
		:response 200: OK
		«FOR r : cmd.response»
				«r.compile»
		«ENDFOR»
		«"'''"»
		return "Ceci est la réponse de la commande «cmd.name»", 200	
	
	'''
	
	def String toMethodParameters(CommandRest rest) {
				
		if(rest.parameters.length == 0) return "";
		var String res = "";

		for(Parameter p : rest.parameters) {
			if(rest.path.path.contains("{" + p.name + "}")) res += p.name + ',';
		}
		
		if(res.length > 0)
			res = res.substring(0, res.length - 1);
			
		return res;
		
	}
	
	def dispatch compile(Parameter p) ''':param «p.type» «p.name»: «p.comment»'''
	
	def String toLowerCase(Method method) {
		return method.toString().toLowerCase();
	}
	
	def dispatch compile(Response r) '''
	:response «r.code»: «r.description»
	'''
	
	def String toFlaskPath(CommandRest cmd) {

		var List<String> allMatches = new ArrayList<String>();
		var Matcher m = Pattern.compile("\\{(\\w+)\\}").matcher(cmd.path.path);
		while(m.find()) {
		  allMatches.add(m.group(1));
		}
		
		var String newpath = cmd.path.path;
		for(String match : allMatches) {
		
			var String type;
			for(Parameter p : cmd.parameters) {
				if(p.name.equals(match)) {
					type = p.type;
				}
			}
			
			newpath = newpath.replace("{" + match + "}", "<" + type + ":" + match + ">");
			
		}
		
		return newpath;
		
	}
	
	def String toConsumes(EList<String> ef) {
		if(ef.isEmpty()) {
			return "";
		} else {
			return "@consumes('" + ef.join('\',\'') + "')";
		}
	}
	
	def String toProduces(EList<String> ef) {
		if(ef.isEmpty()) {
			return "";
		} else {
			return "@produces('" + ef.join('\',\'') + "')";
		}
	}
	
	
}

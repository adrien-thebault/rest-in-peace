/*
 * generated by Xtext 2.12.0
 */
package org.xtext.validation

import java.util.HashSet
import java.util.regex.Pattern
import org.eclipse.xtext.validation.Check
import restInPeace.APIRest
import restInPeace.CommandRest
import restInPeace.Parameter
import restInPeace.Path
import restInPeace.RestInPeacePackage.Literals

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RipDSLValidator extends AbstractRipDSLValidator {
	public static final String METHOD_PATH_ALREADY_DEFINED = "method-path-already-defined";
	public static final String PARAMETER_NOT_DEFINED = "parameter-not-defined";
	public static final String PATH_MUST_BEGINS_WITH_SLASH = "path-must-begin-with-slash";
	public static final String PARAMETER_MUST_NOT_BE_EMPTY = "parameter-must-not-be-empty";
	

	@Check
	def checkPathAndMethodsUnique(APIRest api) {
		val commands = api.commands;
		val commandList = new HashSet<String>();
		for(CommandRest c : commands){
			val string = c.path.path + c.method;
			if(commandList.contains(string)){
				error("Command with path "+c.path.path+" and method "+c.method+" is already defined ಠ_ಠ.", c, Literals.COMMAND_REST__NAME, -1, METHOD_PATH_ALREADY_DEFINED);
			} else {
				commandList.add(string);
			}
		}
	}
	
	@Check
	def checkPathParameter(CommandRest command) {
		var path = command.path.path;
		val matcher = Pattern.compile("/\\{(\\w+)\\}/?").matcher(path);
		while(matcher.find()){
			val parName = matcher.group(1);
			val set = new HashSet<String>();
			for(Parameter p : command.parameters){
				set.add(p.name);
			}
			
			if(!set.contains(parName)){
				error("Command with path "+command.path.path+" and method "+command.method+" has a parameter "+parName+" in the path which is not declared ಥ_ಥ .",
					command, Literals.COMMAND_REST__NAME, -1, PARAMETER_NOT_DEFINED);
			}
		}
	}
	
	@Check
	def checkPathBeginsWithSlash(Path p) {
		if(!p.path.startsWith("/")){
			error("Paths must begin with the character /.",
				p, null, -1, PATH_MUST_BEGINS_WITH_SLASH);
		}
	}
	
	@Check
	def checkParameterIsNotEmpty(Parameter p) {
		if(!p.name.matches(".*\\w.*")){
			error("Parameters name must not be empty.",
				p, Literals.PARAMETER__NAME, -1, PARAMETER_MUST_NOT_BE_EMPTY);
		}
	}
}
